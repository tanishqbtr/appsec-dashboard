You are a senior backend engineer. Inspect this repo and FIX the plaintext password storage. 
Convert to salted, slow hashing with **Argon2id** (fallback to bcrypt only if Argon2 isn’t available). 
Do it with a safe, two-step migration and without breaking current logins.

## Stack assumptions (adapt if different)
- Backend: Node.js + Express + TypeScript
- DB: Postgres with Drizzle ORM
- Current table: `users(username TEXT UNIQUE, password TEXT, type TEXT, status TEXT, created_at, updated_at, ...)`

## High-level goals
1) Hash passwords with **Argon2id** + server-side **pepper** (env). 
2) Migrate existing plaintext passwords → hashes (one-time script).
3) Update all auth paths to use the hash; remove plaintext everywhere.
4) Add basic login rate limiting and uniform errors.
5) Ship `.env.example`, tests, and a brief CHANGELOG.

## Dependencies
- Add: `argon2` (preferred). Also add `express-rate-limit`.
- Types as needed. If Argon2 fails to compile on Replit, fallback to `bcryptjs` (cost 12–14) but keep the Argon2-first code path.

## Config (.env)
Add to `.env.example`:
- `PASSWORD_PEPPER=change-me`
- `ARGON2_TIME_COST=3`
- `ARGON2_MEMORY_COST=65536`
- `ARGON2_PARALLELISM=1`

## DB changes (Drizzle + SQL)
Create a migration that:
1) Adds new columns (nullable for the migration phase):
   - `password_hash TEXT`
   - `password_algo TEXT DEFAULT 'argon2id'`
   - `password_updated_at TIMESTAMPTZ`
2) (Do NOT drop `password` yet.)
3) Add an index on `username` if not present.

Example SQL (adapt to your migration framework):
- `ALTER TABLE users ADD COLUMN IF NOT EXISTS password_hash TEXT;`
- `ALTER TABLE users ADD COLUMN IF NOT EXISTS password_algo TEXT DEFAULT 'argon2id';`
- `ALTER TABLE users ADD COLUMN IF NOT EXISTS password_updated_at TIMESTAMPTZ;`

## Hashing helpers (server/auth/passwords.ts)
Create a small module:
- `hashPassword(plain: string): Promise<string>` → Argon2id with params from env, append `PASSWORD_PEPPER` before hashing.
- `verifyPassword(hash: string, candidate: string): Promise<boolean>` → verify with `candidate + PEPPER`.
- `needsRehash(hash: string): boolean` → returns true if algorithm/params weaker than current → rehash on next login.

Argon2 sample:
```ts
import argon2 from 'argon2';
const PEPPER = process.env.PASSWORD_PEPPER || '';
const opts = {
  type: argon2.argon2id,
  timeCost: Number(process.env.ARGON2_TIME_COST || 3),
  memoryCost: Number(process.env.ARGON2_MEMORY_COST || 65536),
  parallelism: Number(process.env.ARGON2_PARALLELISM || 1),
};
export async function hashPassword(p: string) { return argon2.hash(p + PEPPER, opts); }
export async function verifyPassword(h: string, p: string) { return argon2.verify(h, p + PEPPER); }